# TODO: Guided haplotype learnning
# 
# Author: xzhou
###############################################################################


source("SHC.R")


#' read 1 2 encoded geno data generated by python
#'
readHapData <- function(hapFileName =  "../data/sim_4000seq/80SNP_CEU_sim_4000seq.12encode", popSize, nSnps)
{
	
	if(hapFileName = "")
	{
		hapFileName = "../data/sim_4000seq/80SNP_CEU_sim_4000seq.12encode"
	}
	
	hapData <- read.table(file = hapFileName)
	
	m <- nrow(hapData)
	n <- ncol(hapData)
	
	if(m < popSize || n < 2*nSnps )
	{
		warning("not enough data\n")
		stop()
	}
	
	hapData <- hapData[1:popSize, 1:(2*nSnps)]
	
	hapData
}

count2freq <- function(C)
{
	 F = c[1,]/(C[1,] + C[2,])
	 F
}

#' evaluate
#' @param targetR the target
#' @param 
#' @param 
#' @param K the weight of rs error and frequency error
hapEvaluate <- function(targetRS, targetF, learnedRS, learnedF, K = 0.7)
{	
	
	targetF <- count2freq(targetF)
	learnedF <- count2freq(learnedF)
	
	rsDiff <- targetRS - learnedRS
	rError <- sum(rsDiff*rsDiff, na.rm = T)/2.0
	
	fDiff <- targetF - learnedF
	fError <- sum(fDiff*fDiff, na.rm = T)/2.0
	
	error <- (1-K)*rError + K*fError
	
	error

}


#' for each pair of pairwise count, calculate the grad
#' @param c00
#' @param c0x ... single allele frequency
#' @param learnedRSquare
#' @param targetRSquare
#' @return the gradient agianst c_ij
calcGrad <- function(c00, c0x, c1x, cx0, cx1, N, learnedRSquare, targetRSquare)
{
	K = c0x * c1x * cx0 * cx1
	Z = (learnedRSquare - targetRSquare)
	D = c00*N - c0x*cx0
	delta = 2*Z*D*N/K
	delta
}


#' caluclate the gradient at c_ij, for simplicity, we assume c00 are independent
#' It is not the case when the LD are lardge 
#' @param popSize the population size
#' @param c00 symetric matrix of c00 for each pair
#' @param c0x a row matrix of sngle allele frequency
#' @param learnedRS the current learned r square
#' @param targetRS the targetRS	
gradOfCij <- function(popSize, c00m, c0xm, learnedRS, targetRS)
{
	N <- 2*popSize
	m <- nrow(c00m)
	n <- ncol(c00m)
	
	if( m != n)
	{
		warning("not square matrix\n")
		stop()
	}
	
	grad = matrix(0.0, m, n)
	
	for(i in 1:(m-1))
	{
		for(j in (i+1):m)
		{
			c00 = c00m[i,j]
			
			#calculate single allele frequency
			c0x <- c0xm[i]
			c1x <- N - c0x
			cx0 <- c0xm[j]
			cx1 <- N - cx0
			lrs_ij <- learnedRS[i,j]
			trs_ij <- targetRS[i,j]
			
			delta <- calcGrad(c00, c0x, c1x, cx0, cx1, N, lrs_ij, trs_ij)
			
			grad[i,j] <- grad[j,i] = delta
		}
	}
	grad
}


#' initialize the population given single allele frequency
#' @param pA the single allele frequency of all snps
#' @return the init popupation with pA
#' STATUS not tested
initializePopulation <- function(popSize, nSnps, pA)
{

	#generate a sequence of N*n0 0s and N-n0 1s
	generateASnps <- function(N, n0)
	{
		a = matrix(0, 1, n0)
		b = matrix(1, 1, N-n0)
		
		c = c(a, b)
		c <- sample(c)
		c
	}
	
	if(length(pA) != nSnps)
	{
		warning("nSnps != length(pA)\n")
		stop()
	}
	
	N <- 2*popSize
	
	pop = matrix(0, popSize, 2*nSnps)
	
	for(j in 1:nSnps)
	{
		n0 = pA[1, j]		#see the format of the single allele freq
		n1 = pA[2, j]		#
		aSnp = generateASnps(N, n0)
		print(aSnp)
		for(i in 1:popSize)
		{
			pop[i, 2*j - 1] = aSnp[2*i - 1]
			pop[i, 2*j] = aSnp[2*i]
		}
	}
	pop
}


#' learn haplotype
#' 
#' @param targetHaplotype for simulation, we assume we know the phased genotype
#' 			it remembers the genotype, we use the gradient decrease algorithm
#' @param popSize	The population size of the target haplotype
#' @param nSnps		the number of snps
#' @param nSnps		randomly start 
guidedHapLearning <- function(targetHaplotype, maxTry = 10000)
{
	popSize <- nrow(targetHaplotype)
	nSnps <- ncol(targetHaplotype)/2
	
	#calculate the r rs and single allele frequency
	targetR <- calcualteRealR(targetHaplotype)
	targetF <- calculateSingleAlleleFrequence(targetHaplotype)
	
	#initialize the population given single allele frequency
	initPop <- initializePopulation(popSize, nSnps, targetF)
}

gradGuidedLearningEntry <- function()
{
	targetHaplotype <- readHapData("", 5, 10)
}




